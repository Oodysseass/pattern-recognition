# -*- coding: utf-8 -*-
"""SVM_for_partD.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/Oodysseass/pattern-recognition/blob/romanos/SVM_for_partD.ipynb
"""

#First we will try SVM because:
#    Effective for high-dimensional spaces.
#    Works well for both linear and non-linear data.
#    Can be memory-intensive for large datasets.(our 5000 samples are not that large)
#    We also have it from part C

import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import matplotlib.pyplot as plt

#Loading data
data = np.loadtxt("datasetC.csv", delimiter=",", dtype=np.float64)
print (data)


#Last column containing Labels
features = data[:,0:-1]
labels = data[:, -1]

#Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(features, labels, test_size=0.2, random_state=42)

#Scaling the features
#scaler = StandardScaler()
#X_train_scaled = scaler.fit_transform(X_train)
#X_test_scaled = scaler.fit_transform(X_test)
#print (X_train_scaled)

#Initialize the SVM
classifier = SVC(kernel='rbf', C=1.0, gamma='scale', random_state=42)

# Train the SVM model
classifier.fit(X_train, y_train)

# Make predictions on the test set
y_pred = classifier.predict(X_test)

# Evaluate the performance of the model
accuracy = accuracy_score(y_test, y_pred)
conf_matrix = confusion_matrix(y_test, y_pred)
classification_rep = classification_report(y_test, y_pred)

print(f'Accuracy: {accuracy:.2f}')
print('\nConfusion Matrix:')
print(conf_matrix)
print('\nClassification Report:')
print(classification_rep)